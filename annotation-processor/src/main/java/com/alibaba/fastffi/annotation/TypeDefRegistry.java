/*
 * Copyright 1999-2021 Alibaba Group Holding Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.alibaba.fastffi.annotation;

import com.alibaba.fastffi.CXXTemplate;
import com.alibaba.fastffi.FFIGen;
import com.alibaba.fastffi.FFIGenBatch;
import com.alibaba.fastffi.FFILibrary;
import com.alibaba.fastffi.FFITypeAlias;

import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Properties;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Stream;

import static com.alibaba.fastffi.annotation.AnnotationProcessorUtils.getTypeElement;
import static com.alibaba.fastffi.annotation.AnnotationProcessorUtils.isSameFFIGen;
import static com.alibaba.fastffi.annotation.AnnotationProcessorUtils.toHeaderGuard;

public class TypeDefRegistry {

    static String normalize(String cxx) {
        return cxx.replace("const ", "");
    }

    static class Key {
        String cxx;
        String java;

        public Key(String cxx, String java) {
            this.cxx = normalize(cxx);
            this.java = java;
        }

        public String toString() {
            return "<" + cxx + "," + java + ">";
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Key key = (Key) o;
            return Objects.equals(cxx, key.cxx) && Objects.equals(java, key.java);
        }

        @Override
        public int hashCode() {
            return Objects.hash(cxx, java);
        }
    }

    AnnotationProcessor processor;

    private Map<Key, TypeDef> FFIPointerDefMap = new HashMap<>();
    private Map<Key, TypeDef> FFILibraryDefMap = new HashMap<>();
    private Map<Key, TypeDefGenerator> FFIMirrorGeneratorMap = new HashMap<>();
    /**
     * Each FFIMirror has its own header file.
     * All heads of FFIMirror in the same JNI library is grouped into another header file.
     */
    private Map<String, List<TypeDefGenerator>> FFIMirrorMapGroupByLibraryName = new HashMap<>();
    /**
     * A template is simply a map between the Java interface name and the type def.
     */
    private Map<String, TypeDef> FFITemplateDefMap = new HashMap<>();

    /**
     * Must be one-one mapping for all FFIPointer and FFILibrary
     * The uniqueName is generated by fastFFI
      */
    private Map<String, TypeDef> uniqueJavaNameToTypeDef = new HashMap<>();

    /**
     * A set to record @FFIGens that has already been added
     */
    private Set<Key> generatedTypeDefs = new HashSet<>();

    private List<TypeDefGenerator> ffiTemplateList = new ArrayList<>();
    private List<TypeDefGenerator> ffiPointerOrFFILibraryList = new ArrayList<>();

    public TypeDefRegistry(AnnotationProcessor processor) {
        this.processor = processor;
    }

    /**
     *
     * @param foreignType
     * @param typeMirror
     * @param typeElement
     * @param genIfMissing: create the missing TypeDef and generate code for the TypeDef
     * @return may be null
     */
    public TypeDef getTypeDefByForeignName(String foreignType, DeclaredType typeMirror, TypeElement typeElement, boolean genIfMissing) {
        Key key = toKey(foreignType, typeElement);
        TypeDef typeDef = FFIPointerDefMap.get(key);
        if (typeDef == null) {
            FFIGen ffiGen = typeElement.getAnnotation(FFIGen.class);
            if (ffiGen != null) {
                if (!genIfMissing) {
                    processor.processType(typeElement, false);
                } else {
                    if (typeElement.getTypeParameters().isEmpty()) {
                        processor.processType(typeElement, ffiGen, null, true);
                    } else {
                        // Now we need to create a CXXTemplate from typeMirror
                        CXXTemplate template = getCXXTemplateForBuiltinType(typeMirror);
                        processor.processType(typeElement, ffiGen, template,true);
                    }
                }
            }
            typeDef = FFIPointerDefMap.get(key);
        }
        return typeDef;
    }

    private CXXTemplate getCXXTemplateForBuiltinType(DeclaredType typeMirror) {
        TypeEnv typeEnv = processor.getTypeEnv();
        return typeEnv.getCXXTemplateForBuiltinType(typeMirror);
    }

    public boolean registerFFITemplateTypeDef(TypeDef def, TypeDefGenerator generator, boolean gen) {
        if (registerFFITemplateTypeDef(def)) {
            if (gen) addGenerator(generator);
            return true;
        }
        return false;
    }

    public TypeDef getFFITemplateTypeDef(String typeName) {
        return FFITemplateDefMap.get(typeName);
    }

    /**
     *
     * @param def
     * @return
     */
    private boolean registerFFITemplateTypeDef(TypeDef def) {
        String key = def.getDeclaredTypeElementName();
        TypeDef check = this.FFITemplateDefMap.get(key);
        if (check == null) {
            this.FFITemplateDefMap.put(key, def);
            return true;
        }
        return false;
    }

    public void registerFFIPointerTypeDef(TypeDef def, TypeDefGenerator generator, boolean gen) {
        registerFFIPointerTypeDef(def);
        if (gen && genIfMissing(def)) {
            addGenerator(generator);
            generator.instantiateSuperTemplates();
        }
    }

    public String getFFIMirrorHeaderName(TypeDef typeDef) {
        TypeDefGenerator defGenerator = FFIMirrorGeneratorMap.get(toKey(typeDef));
        if (defGenerator == null) {
            throw new IllegalStateException("Cannot find FFIMirror generator for " + typeDef);
        }
        return defGenerator.getGeneratedHXXFileName();
    }

    private boolean registerFFIPointerTypeDef(TypeDef def) {
        Key key = toKey(def);
        boolean added = this.FFIPointerDefMap.containsKey(key);
        if (added) return false;
        this.FFIPointerDefMap.put(key, def);
        this.uniqueJavaNameToTypeDef.put(def.getGeneratedJavaClassName(), def);
        return true;
    }

    private boolean genIfMissing(TypeDef def) {
        Key key = toKey(def);
        return generatedTypeDefs.add(key);
    }

    static Key toKey(String foreignType, TypeElement typeElement) {
        return new Key(foreignType, typeElement.getQualifiedName().toString());
    }

    static Key toKey(TypeDef typeDef) {
        return new Key(typeDef.getTypeRegistryId(), typeDef.getDeclaredTypeElementName());
    }

    public void addGenerator(TypeDefGenerator generator) {
        if (generator.isGenFFILibrary() || generator.isGenFFIPointer()) {
            ffiPointerOrFFILibraryList.add(generator);
            if (generator.getTypeDef().isFFIMirror()) {
                registerFFIMirror(generator);
            }
            return;
        }
        if (generator.isGenFFITemplate()) {
            ffiTemplateList.add(generator);
            return;
        }
        throw new IllegalStateException("Do not know how to generate " + generator.getTypeDef());
    }

    private void registerFFIMirror(TypeDefGenerator generator) {
        if (FFIMirrorGeneratorMap.put(toKey(generator.getTypeDef()), generator) != null) {
            return;
        }
        {
            String libraryName = generator.getLibraryName();
            List<TypeDefGenerator> libraryDefGenerator =
                FFIMirrorMapGroupByLibraryName.computeIfAbsent(libraryName, k -> new ArrayList<>());
            libraryDefGenerator.add(generator);
        }
    }

    public String getFFIMirrorLibraryHeaderName(TypeDefGenerator generator) {
        return getFFIMirrorLibraryHeaderName(generator.getLibraryName());
    }

    public String getFFIMirrorLibraryHeaderName(String libraryName) {
        if (libraryName == null || libraryName.isEmpty()) {
           return "fastffi.h";
        }
        return libraryName + "-ffi.h";
    }

    private boolean registerFFILibraryTypeDef(TypeDef def) {
        Key key = toKey(def);
        boolean added = FFILibraryDefMap.containsKey(key);
        if (added) return false;
        this.FFILibraryDefMap.put(key, def);
        this.uniqueJavaNameToTypeDef.put(def.getGeneratedJavaClassName(), def);
        return true;
    }

    public void registerFFILibraryTypeDef(TypeDef def, TypeDefGenerator generator, boolean gen) {
        if (registerFFILibraryTypeDef(def)) {
            if (gen) addGenerator(generator);
        }
    }

    static void writeProperties(ProcessingEnvironment processingEnv, Properties properties, String pkg, String relativeName) throws IOException {
        Filer filer = processingEnv.getFiler();
        FileObject fileObject;
        try {
            fileObject = filer.getResource(StandardLocation.CLASS_OUTPUT, pkg, relativeName);
            try (Reader reader = fileObject.openReader(true)) {
                Properties existing = new Properties();
                existing.load(reader);
                properties = mergeProperties(properties, existing);
            }
        } catch (IOException exception) {
        }
        fileObject = filer.createResource(StandardLocation.CLASS_OUTPUT, pkg, relativeName);
        try (Writer writer = fileObject.openWriter()) {
            properties.store(writer, "Generated by alibaba/fastFFI");
            writer.flush();
        }
    }

    static private Properties mergeProperties(Properties... properties) {
        return Stream.of(properties)
                .collect(Properties::new, Map::putAll, Map::putAll);
    }

    public void generate() {
        // First expand all templates
        if (generateFFITemplate()) {
            return;
        }
        generateFFIPointerFFILibrary();
    }

    public boolean generateFFITemplate() {
        return processWorklist(ffiTemplateList, generator -> {
            if (generator.isCreated()) {
                generator.generate();
                return true;
            }
            return false;
        });
    }

    boolean processWorklist(List<TypeDefGenerator> worklist, Function<TypeDefGenerator, Boolean> function) {
        if (worklist.isEmpty()) {
            return false;
        }
        int begin = 0; int end = worklist.size();
        boolean hasGenerated = false;
        while (true) {
            // now we can accept new template during generate FFITemplate
            for (int i = begin; i < end; i++) {
                TypeDefGenerator generator = worklist.get(i);
                hasGenerated |= function.apply(generator);
            }
            if (end == worklist.size()) {
                break;
            }
            begin = end;
            end = worklist.size();
        }
        return hasGenerated;
    }

    public void generateFFIPointerFFILibrary() {
        processWorklist(ffiPointerOrFFILibraryList, generator -> {
            if (generator.isCreated()) {
                generator.generate();
                return true;
            }
            return false;
        });
    }

    void lastRound(ProcessingEnvironment processingEnv) {
        // after all have done.
        writeProperties(processingEnv);
    }

    void writeProperties(ProcessingEnvironment processingEnv) {
        if (!FFIPointerDefMap.isEmpty()) {
            Properties properties = new Properties();
            FFIPointerDefMap.forEach( (key, value) -> properties.put(value.getGeneratedJavaClassName(), key.cxx));

            try {
                writeProperties(processingEnv, properties, "", "ffi.properties");
            } catch (IOException exc) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                        "" + exc.getClass().getName() + ": failed to write ffi.properties: " + exc.getMessage());
            }
        }
        if (!FFILibraryDefMap.isEmpty()) {
            Properties properties = new Properties();
            FFILibraryDefMap.forEach( (key, value) -> properties.put(value.getGeneratedJavaClassName(), key.cxx));

            try {
                writeProperties(processingEnv, properties, "", "ffilibrary.properties");
            } catch (IOException exc) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                        "" + exc.getClass().getName() + ": failed to write ffilibrary.properties: " + exc.getMessage());
            }
        }
        writeFFIMirrorHead(processingEnv);
    }

    private void writeFFIMirrorHead(ProcessingEnvironment processingEnv) {
        FFIMirrorMapGroupByLibraryName.forEach((k, v) -> {
            StringBuilder hxx = new StringBuilder();
            String header = getFFIMirrorLibraryHeaderName(k);
            String guard = toHeaderGuard(header);
            hxx.append("#ifndef ").append(guard).append("\n");
            hxx.append("#define ").append(guard).append("\n");
            v.forEach(gen -> {
                gen.generateFFIMirrorHeader();
                hxx.append("#include \"").append(gen.getGeneratedHXXFileName()).append("\"\n");
            });
            hxx.append("#endif // ").append(guard).append("\n");

            try {
                FileObject fileObject = processingEnv.getFiler().createResource(processor.cxxOutputLocation,
                        "", header);
                try (Writer writer = fileObject.openWriter()) {
                    writer.write(hxx.toString());
                    writer.flush();
                }
            }catch (IOException e) {
                throw new IllegalStateException("Cannot write " + header + " due to " + e.getMessage(), e);
            }
        });
    }

    void processType(ProcessingEnvironment processingEnv, TypeElement typeElement, CXXTemplate template, boolean gen) {
        processType(processingEnv, typeElement, typeElement.getAnnotation(FFIGen.class), template, gen);
    }

    void processType(ProcessingEnvironment processingEnv, TypeElement typeElement, FFIGen ffiGen, boolean gen) {
        // No support for non-interface classes
        if (typeElement.getKind() != ElementKind.INTERFACE) {
            throw new IllegalArgumentException("TODO: We only support generate code for interfaces");
        }
        FFITypeAlias typeAlias = typeElement.getAnnotation(FFITypeAlias.class);
        FFILibrary ffiLibrary = typeElement.getAnnotation(FFILibrary.class);
        if (typeAlias == null) {
            if (ffiLibrary == null) {
                throw new IllegalArgumentException("TODO: We need a FFITypeAlias annotation to mark foreign type name for " + typeElement);
            }
        } else {
            if (ffiLibrary != null) {
                throw new IllegalArgumentException("TODO: We cannot have a FFITypeAlias annotation for FFILibrary " + typeElement);
            }
        }

        if (!typeElement.getTypeParameters().isEmpty()) {
            CXXTemplate[] templates = typeElement.getAnnotationsByType(CXXTemplate.class);
            for (CXXTemplate template : ffiGen.templates()) {
                processType(processingEnv, typeElement, ffiGen, template, gen);
            }
            if (templates == null) {
                return;
            }
            for (CXXTemplate template : templates) {
                processType(processingEnv, typeElement, ffiGen, template, gen);
            }
        } else {
            processType(processingEnv, typeElement, ffiGen, null, gen);
        }
    }

    void processTypeBatch(ProcessingEnvironment processingEnv, FFIGenBatch genBatch, boolean doGen) {
        if (genBatch == null) {
            throw new IllegalStateException("Oops: must have FFIGenBatch");
        }
        for (FFIGen gen : genBatch.value()) {
            TypeElement theTypeElement = getTypeElement(processingEnv, gen.type());
            CXXTemplate[] templates = gen.templates();
            if (theTypeElement.getTypeParameters().isEmpty()) {
                if (templates.length > 0) {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE,
                            "Redundant templates for " + theTypeElement + " in " + gen, theTypeElement);
                }
                processType(processingEnv, theTypeElement, gen, doGen);
            } else {
                if (templates.length == 0) {
                    throw new FFIIllegalStateException("A generic type requires CXXTemplate: " + gen, theTypeElement);
                }
                for (CXXTemplate template : templates) {
                    processType(processingEnv, theTypeElement, gen, template, doGen);
                }
            }
        }
    }


    void processType(ProcessingEnvironment processingEnv, TypeElement typeElement,
                                 FFIGen ffiGen, CXXTemplate template, boolean gen) {
        TypeDef def = new TypeDef(typeElement, ffiGen, template, processor.compactFFINames);
        TypeDefGenerator generator = new TypeDefGenerator(this, processingEnv, typeElement, def, template);
        if (generator.isGenFFITemplate()) {
            registerFFITemplateTypeDef(def, generator, gen);
        } else if (generator.isGenFFIPointer()) {
            registerFFIPointerTypeDef(def, generator, gen);
        } else if (generator.isGenFFILibrary()) {
            registerFFILibraryTypeDef(def, generator, gen);
        } else {
            throw new IllegalArgumentException("Unknown generation type for " + typeElement);
        }
    }
}
